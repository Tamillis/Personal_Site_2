<template>
    <div className="app-body">
        <h3 className="subtitle">My Point Buy Calculator</h3>

        <p className="main-text subtitle-synopsis">
            <p className="inline-subtitle">[[This calculator used to be built using React!]]</p>
            Calculate the points cost of your attributes, following the standard set by my Improved Standard Array
            above, inspired by the base D&D5e rules, but tweaked for heroic adventuring. You cannot go above 16 or below 7 per attribute, and your point total
            cannot exceed 30. See the table to follow how much each attribute value costs.
        </p>

        <div className="app-main">
            <div className="calculator-body">
                <p className="main-text inline-subtitle underline">Points: {{currPointTotal}} / {{POINTMAX}}</p>
                <div className="statblocs-container">
                    <Statbloc v-for="(value, key) in data" :attribute=key :value=value
                        @updateAttribute="updateAttribute" />
                </div>
            </div>
            <StatCalcTable :mapping=mapping />
        </div>
    </div>
</template>

<script setup>
import { reactive, ref } from 'vue';
import Statbloc from './Statbloc.vue';
import StatCalcTable from './StatCalcTable.vue';

const data = reactive({
    Strength: 10,
    Dexterity: 10,
    Constitution: 10,
    Intelligence: 10,
    Wisdom: 10,
    Charisma: 10
})

const mapping = {
    7: -1,
    8: 0,
    9: 1,
    10: 2,
    11: 3,
    12: 4,
    13: 5,
    14: 7,
    15: 9,
    16: 12
}

//global constant, modified from D&D 5e
const POINTMAX = 30;

//calc current point total
let currPointTotal = ref(0);

const updateAttribute = (attribute, valueChange) => {
    //check the data isn't making the attributes illegal values
    if (data[attribute] + valueChange > 16 || data[attribute] + valueChange < 7) return;
    //check change doesnt violate max point cost if so return out

    let newData = {...data}
    newData[attribute] += Number(valueChange)

    if (!overflows(newData)) {
        //otherwise set data to newData
        data[attribute] += Number(valueChange)

        //and update point total
        currPointTotal.value = 0;
        Object.values(data).forEach(value => { currPointTotal.value += mapping[value]; });
    }
}

const overflows = (newData) => {
    let newPointTotal = 0
    Object.values(newData).forEach(value => newPointTotal += mapping[value]) 

    return newPointTotal > POINTMAX
}

//by summing over all the values and adding them up using an inline arrow function and the forEach array function being called
//from the values array generated by the Object.values() prototype function.
Object.values(data).forEach(val => { currPointTotal.value += mapping[val]; });

</script>

<style scoped>
.app-body {
    background-color: #2a2e31;
    border: groove 4px var(--contrastColor);

    margin: 5px;
    padding: 1em;
}

.app-main {
    display: flex;
    justify-content: flex-start;
    flex-wrap: wrap;

    align-items: stretch;

    padding: 5px;
}

.calculator-body {
    flex-basis: max(16rem, 20vw);
    /* border: 2px var(--color) groove; */
    margin: 0px 1em;
}
</style>